package  {	import flash.geom.Point;	import flash.display.MovieClip;			public class GameManager {				//all of the hidden objects		private var hiddenObjects:Vector.<HiddenObject>;				//the object that is currently being searched for		private var objToFindIndex:int;				//the number of consecutive ticks this object has been viewed		private var foundTicks:int = 0;				//the number of ticks needed to view this object before it is FOUND		private var foundThreshold:int = 3;				//numPoints		var numPoints:int = 0;				//object to manage sounds		var soundManager:SoundEffects;				//the game timer		var gameTimer:GameTimer;								public function GameManager(theTimer:GameTimer, soundsEnabled:Boolean) {			gameTimer = theTimer;						soundManager = new SoundEffects(soundsEnabled);									soundManager.startBackgroundMusic();			hiddenObjects = new Vector.<HiddenObject>();		}				public function addHiddenObject(newObject:HiddenObject):void{			if(hiddenObjects.indexOf(newObject) == -1){				hiddenObjects.push(newObject);			}		}				public function getHiddenObject(index:int):HiddenObject{			if(index>=0 && index<hiddenObjects.length){				return hiddenObjects[index];			}						return null;		}				public function setObjectToFind(index:int):void{			objToFindIndex = index;		}				private function setFoundObject(index:int, bonus:Boolean):void{			if(index>=0 && index<hiddenObjects.length){				hiddenObjects[index].setFound();				numPoints += hiddenObjects[index].getPoints();								if(bonus){					numPoints += 8;				}			}								}				private function getNewObjectToFind():void{			var newIndex:int = (Math.random()*hiddenObjects.length);						while(newIndex == objToFindIndex){				newIndex = (Math.random()*hiddenObjects.length);			}						objToFindIndex = newIndex;						trace("now looking for: " + getObjectName(newIndex));		}				public function getObjectName(index:int):String{			return hiddenObjects[index].getName();		}				public function getObjectToFindName():String{			return getObjectName(objToFindIndex);		}				public function getNumPoints():int{			return numPoints;		}				public function gameManagerTick(xPos:int, yPos:int, stage:MovieClip):void{			//get the x and y position of the object to be found						var objToFind:HiddenObject = hiddenObjects[objToFindIndex];			if(distance(new Point(xPos,yPos), new Point(objToFind.getX(), objToFind.getY())) < 20){				foundTicks++;								if(foundTicks ==foundThreshold){					stage.playCheckMark();					foundObject();				}				else{					trace("waiting");				}			}					}				//called when an object is found		private function foundObject():void{			var bonus:Boolean = false;						if(gameTimer.timerValue <=20){				bonus = true;							}						foundTicks=0;						randomPosition(getHiddenObject(objToFindIndex).theObject);			setFoundObject(objToFindIndex, bonus);			getNewObjectToFind();			trace("found it!  game timer is: " + gameTimer.timerValue);									if(bonus){				soundManager.playCheerSound();				soundManager.playDingSound();			}			else{				soundManager.playDingSound();			}						gameTimer.resetTimer();					}				function randomPosition(object:MovieClip):void{			var header:Header = new Header();			object.x = Math.random()*800;			object.y = (Math.random() - header.height/500)*500 + header.height;			trace(object + " = " + object.x + ", " + object.y);						if (object.x <= object.width/2){				object.x += (object.width/2);				trace("RESIZE X! " + object + " = " + object.x);			}			else if (object.x >= (800 - object.width/2)) {				object.x -= (object.width/2);				trace("RESIZE X! " + object + " = " + object.x);			}						if (object.y <= object.height/2 + header.height){				object.y += (object.height/2);				trace("RESIZE Y! " + object + " = " + object.y);			}			else if (object.y >= (500 - object.height/2 - header.height)) {				object.y -= (object.height/2);				trace("RESIZE Y! " + object + " = " + object.y);			}		}				private function distance(point1:Point, point2:Point):uint{						return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y-point2.y,2));		}	}	}