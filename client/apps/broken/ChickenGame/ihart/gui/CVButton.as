package ihart.gui{	import flash.events.*;	import flash.display.Shape;	import flash.display.MovieClip;	import flash.display.SimpleButton;	import ihart.event.*;	/**	* CVButton	* @author Cleo Schneider	* @author Felicia Cordeiro	* last updated 12/23/10	*	* CVButton extends the button class and contains all of its functionality, but overrides the event listener	* listen for hole, shell, and face events from the CVManager	**/	public class CVButton extends SimpleButton{		/**		* Fields		**/		//constants		private static const DELAY: int = 10;		//instances		private var delay : int = DELAY;		private var cv_man : CVManager;		private var dispatcher : EventDispatcher;		private var h_enabled:Boolean, s_enabled:Boolean,a_enabled:Boolean,f_enabled : Boolean;				//set up the socket with localhost, using port 5204		private var hostName:String = "localhost";        private var port:uint = 5204;								/**		* Constructor		* calls super, initializes the enabled events, sets up the CVManager, and adds event listeners		**/		public function CVButton(){			//make a call to super to inherit all necessary functions			super();						//initialize the enabled events			h_enabled = false;			s_enabled = false;			f_enabled=false;			a_enabled=false;						//the cv manager to worry about dispatched events			cv_man = new CVManager(hostName, port);						//add listeners to the cv manager			cv_man.addEventListener("hole", holesReceived);			cv_man.addEventListener("shell", shellsReceived);			cv_man.addEventListener("face", facesReceived);			cv_man.addEventListener("all blobs", allBlobsReceived);		}				/**		* enable		* enable shells or holes faces or some combination		* this dictates whether click events will work with your buttons		* It is necessary that this method be called if the user wants to use clicks		* return void		**/		public function enable(type : String) : void{			//if the type matches holes than enable holes			if(type == CVEvent.HOLE){				h_enabled = true;			}			//if the type matches shells than enable shells			if(type == CVEvent.SHELL){				s_enabled = true;			}			if(type == CVEvent.FACE){				f_enabled = true;			}			if((type == CVEvent.ALL_BLOBS) || (f_enabled && s_enabled && h_enabled)){				a_enabled=true;			}		}				/**		* allBlobsRecieved		* when any blobs are recieved, if we have enabled holes and shells, a blob overlaps, and stays there for long enough		* dispatch a click event		* return void		**/		public function allBlobsReceived(e : CVEvent) : void{			buttonClickCheck(e,a_enabled);		}				/**		* facesRecieved		* when faces are recieved, if we have enabled faces, a face overlaps, and stays there for long enough		* dispatch a click event		* return void		**/		public function facesReceived(e : CVEvent) : void{ 			buttonClickCheck(e,f_enabled);		}				/**		* holesRecieved		* when holes are recieved, if we have enabled holes, a hole overlaps, and stays there for long enough		* dispatch a click event		* return void		**/		public function holesReceived(e : CVEvent) : void{ 			buttonClickCheck(e,h_enabled);		}				/**		* shellsRecieved		* when shells are recieved, if we have enabled shells, a shell overlaps, and stays there for long enough		* dispatch a click event		* return void		**/		public function shellsReceived(e : CVEvent) : void{			buttonClickCheck(e,s_enabled);		}				/**		* checkOverlap		* Checks if faces are enabled, if they are, check if any part of any of the face rectangles overlap the button		* If faces are not enabled, check if any other type is and if any of the other types are, check if 2/3 of the blob is overlapping the button		* return: true if 2/3 of the blob, or a face is overlapping the button		* 		  else return false		**/		public function checkOverlap(blobx : int, bloby : int, blobW : int, blobH : int):Boolean{			if(f_enabled){				var rect:Shape = new Shape();				rect.graphics.drawRect(blobx, bloby, blobW, blobH);								if(this.hitTestObject(rect)){					return true;				}			}						if(s_enabled || h_enabled || a_enabled){				//calculate the range of x values and the range of y values for the blob				var lxbound : int = blobx - blobW/2;				var uybound : int = bloby - blobH/2;								//create a new sprite to test overlap				var rect2:Shape = new Shape();				rect2.graphics.drawRect(lxbound, uybound, blobW, blobH);								//then test to see if any corner of the bounding rect is overlapping with the button's corner				if(this.hitTestObject(rect2)){					return true;				}			}						//there was no overlap			return false;		}				/**		* buttonClickCheck		* checks if the type is enabled, if it is, it goes through the different 		* blobs in the event to check for overlap with the button		* return void		**/		private function buttonClickCheck(e:CVEvent, typeEnabled:Boolean):void{			for(var i: int = 0; i< e.getNumBlobs(); i++){				//if type is enabled				if(typeEnabled){					//check for overlap with the button					if(checkOverlap(e.getX(i), e.getY(i), e.getWidth(i), e.getHeight(i))){						//if the delay is greater than 0 then decrement						if(delay>0){							delay--;							//break out of the loop so we don't doubly decrement for this event							break;						}else{							//reset the delay							delay = DELAY;							//dispatch a click event							dispatchEvent(new Event(MouseEvent.CLICK));							//stop walking we don't care about two blobs over the button							break;						}					}				}			}		}	}}