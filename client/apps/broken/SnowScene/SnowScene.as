package {	/*	 * FLINT PARTICLE SYSTEM	 * .....................	 * 	 * Author: Richard Lord	 * Copyright (c) Richard Lord 2008-2010	 * http://flintparticles.org/	 * 	 * Licence Agreement	 * 	 * Permission is hereby granted, free of charge, to any person obtaining a copy	 * of this software and associated documentation files (the "Software"), to deal	 * in the Software without restriction, including without limitation the rights	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell	 * copies of the Software, and to permit persons to whom the Software is	 * furnished to do so, subject to the following conditions:	 * 	 * The above copyright notice and this permission notice shall be included in	 * all copies or substantial portions of the Software.	 * 	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN	 * THE SOFTWARE.	 */	 import flash.display.MovieClip;	 import flash.events.Event;	 import flash.geom.Point;	 	 import ihart.event.*;	import org.flintparticles.common.actions.ActionBase;	import org.flintparticles.common.counters.*;	import org.flintparticles.common.displayObjects.RadialDot;	import org.flintparticles.common.initializers.*;	import org.flintparticles.twoD.actions.*;	import org.flintparticles.twoD.emitters.Emitter2D;	import org.flintparticles.twoD.initializers.*;	import org.flintparticles.twoD.renderers.*;	import org.flintparticles.twoD.zones.*;	//addChild( new SnowBackground() );	public class SnowScene extends MovieClip {				private var collisionZones:Vector.<CollisionZone>;		private var deathZones:Vector.<DeathZone>;		private var spheres:Vector.<CrystalSphere>;				private var count : int;		//		private var zone:DiscZone;		private var emitter:Emitter2D;				// fields for setting up the socket with localhost, using port 5204		private var hostName:String = "localhost";//		private var hostName:String = "192.168.10.1"; //hallway        private var port:uint = 5204;		private var cvManager : CVManager;						public function SnowScene() {						collisionZones = new Vector.<CollisionZone>();			deathZones = new Vector.<DeathZone>();			spheres = new Vector.<CrystalSphere>();			// create a CVManager to mange CV events			cvManager = new CVManager( hostName, port );						// register for HULL events, hook up to hullsArrive method			cvManager.addEventListener( CVEvent.SHELL, hullsArrive );						count = -1;		}		public function init():void {			emitter = new Emitter2D();			emitter.counter=new Steady(300);			emitter.addInitializer( new ImageClass( RadialDot, 2 ) );			emitter.addInitializer( new Position( new LineZone( new Point( -5, -5 ), new Point( 805, -5 ) ) ) );			emitter.addInitializer( new Velocity( new PointZone( new Point( 0, 165 ) ) ) );			emitter.addInitializer( new ScaleImageInit( 0.75, 4 ) );			emitter.addAction( new Move() );			emitter.addAction( new DeathZone( new RectangleZone( -10, -10, 820, 520 ), true ) );			emitter.addAction( new RandomDrift( 20, 20 ) );			//zone =new DiscZone(new Point(245,275),50);			//emitter.addAction( new CollisionZone( zone, 0 ) );			var renderer:DisplayObjectRenderer = new DisplayObjectRenderer();			renderer.addEmitter( emitter );			addChild( renderer );			emitter.start();			emitter.runAhead( 10 );		}		/** 		 * Called when hulls event occurs.		 **/		public function hullsArrive( e : CVEvent )		{			// store the number of received hulls			// ask the event to give us the data			var numHulls : int = e.getNumBlobs();						//trace( "got " + numHulls + " hulls!" );						var maxBlobDim : int = 0;			var currentBlobMaxDim : int;			var currentZone : ActionBase;			var currentDiscZone : DiscZone;						// for each hull			for ( var i : int = 0; i < numHulls; i++ )			{				currentBlobMaxDim = Math.max(e.getWidth( i ), e.getHeight( i ));				// if not enough slots				if ( i >= collisionZones.length )				{					currentZone = 						new CollisionZone( 							new DiscZone( new Point(e.getX( i ),e.getY( i )),										  currentBlobMaxDim/2),							0 );					collisionZones.push( currentZone );					emitter.addAction( currentZone );										currentZone = 						new DeathZone( 							new DiscZone( new Point(e.getX( i ),e.getY( i )),										  currentBlobMaxDim/3) );					deathZones.push( currentZone );					emitter.addAction( currentZone );										//addSphere( e.getX( i ),e.getY( i ), currentBlobMaxDim/2);				}				// otherwise, use the ith zone				else				{					// collision zone					currentDiscZone = DiscZone( collisionZones[i].zone );					currentDiscZone.centerX = e.getX( i );					currentDiscZone.centerY = e.getY( i );					currentDiscZone.outerRadius = currentBlobMaxDim/2;										// death zone					currentDiscZone = DiscZone( deathZones[i].zone );					currentDiscZone.centerX = e.getX( i );					currentDiscZone.centerY = e.getY( i );					currentDiscZone.outerRadius = currentBlobMaxDim/3;					//modifySphere( i, e.getX( i ),e.getY( i ), currentBlobMaxDim/2 );				}			}						// delete potential unused zones			if ( collisionZones.length > numHulls )			{				// remove from back				for ( var j : int = collisionZones.length - 1; j > numHulls-1; j-- )				{					emitter.removeAction( collisionZones.pop() );					emitter.removeAction( deathZones.pop() );					//removeChild( spheres.pop() );				}			}			//trace( "numspheres: " + spheres.length );			// to reset			// if not counting			if ( count == -1 )				startCounting();			count = 0;		}				private function startCounting() : void 		{			addEventListener( Event.ENTER_FRAME, countTicks );		}				private function stopCounting() : void 		{			count = -1;			removeEventListener( Event.ENTER_FRAME, countTicks );		}				public function countTicks( e : Event ) : void		{			count++;						// if it's been a while			// more than 3 seconds			if ( count / 30 > 1 )			{				// let it snow everywhere!				clearZones();				stopCounting();			}		}				private function clearZones() : void		{			// remove from back			for ( var j : int = collisionZones.length - 1; j >= 0; j-- )			{				emitter.removeAction( collisionZones.pop() );				emitter.removeAction( deathZones.pop() );			}		}				private function addSphere( xCoord : int, yCoord : int, rad : int ) : void		{			var sphere : CrystalSphere = new CrystalSphere();			sphere.x = xCoord;			sphere.y = yCoord;			sphere.width = rad;			sphere.height = rad;						spheres.push( sphere );			addChild( sphere );		}		private function modifySphere( index : int, xCoord : int, yCoord : int, rad : int ) : void		{			spheres[index].x = xCoord;			spheres[index].y = yCoord;			spheres[index].width = rad;			spheres[index].height = rad;					}	}}