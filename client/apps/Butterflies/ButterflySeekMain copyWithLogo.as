package {		import flash.display.MovieClip;    import flash.net.XMLSocket;	import flash.geom.Vector3D;	import flash.events.*;	import ihart.event.*;	import ihart.demo.AbstractDemo;	import ihart.soulwire.ai.Boid;		/**	* CVMultiBlobSeek	* @author CleoSchneider	* A flock of boids is sent after targets attained by the CVEvent	* Uses Boid library	*/	public class ButterflySeekMain extends AbstractDemo	{			/**		* Fields		**/		//set up the socket with localhost, using port 5204		protected var hostName:String = "localhost";        protected var port:uint = 5204;		protected var cvManager : CVManager;				private var _targets : Vector.<Vector3D>;		private var _numGroups : int;				/**		* Constructor		**/		public function ButterflySeekMain(){			super();			var logo :MovieClip =  new MHCCSTween();			logo.y -=50;			logo.x = 200;			addChild( logo );		}				/**		* Initialize the server and create the boids		**/		override protected function init() : void		{				//create a cvManager to dispatch a whole blob event			cvManager = new CVManager(hostName, port);			//we must add an event listener to the cv manager in order to know when			//we have received data			cvManager.addEventListener(CVEvent.HULL, getData);			createBoids(60);						_targets = new Vector.<Vector3D>();		}				// override to draw butterfly!		override protected function createBoid() : Boid		{			var boid : Boid = new Boid();						setProperties(boid);			boid.renderData = boid.createBitmapShape(new Butterfly(28, 24));  					_boids.push(boid);			_boidHolder.addChild(boid.renderData);						return boid;		}				/**		* Override update boid to do nothing		**/		override protected function updateBoid(boid : Boid, index : int) : void		{		}				/**		* Get all information from the event		* Split the targets up appropriately		**/		private function getData(e : CVEvent) : void{			var numBlobs : int = e.getNumBlobs();						// if more blobs than targets			if ( numBlobs > _targets.length )			{				// make space for them				for ( var k : int = 0; k < numBlobs - _targets.length; k++ )				{					_targets.push(new Vector3D());				}			}			//for every blob push a new vector into the array and then 			//get the x and y from the event			for(var i : int = 0; i < numBlobs; i++){				_targets[i].x = e.getX(i);				_targets[i].y = e.getY(i);								trace("target " + i + ": " + e.getX(i));			}		}				/**		* Update the target for each boid in the group		**/		private function updateBoidTarget(boid: Boid, index : int, target: Vector3D) : void		{			// Seek and arrive are similar, though arrive			// will cause the boid to slow down as it reaches it's target			boid.arrive(target, 100, 0.8);						//boid.flee(target, 100, 0.8);						// Add some wander to keep it interesting			boid.wander();						boid.update();			boid.render();		}				/**		* Continually update the target by walking over all the boids,		* splitting the boids into groups if there are multiple targets		**/		protected override function step(event : Event = null) : void		{				//define the interval			var interval : int = Math.ceil(_boids.length/_targets.length);						for (var i : int = 0;i < _boids.length; i++)			{				//get the correct bin based on the interval				var currentBin : int = Math.floor(i/interval);				if(_targets.length !=0){					//pass the appropriate target vector					updateBoidTarget(_boids[i], i, _targets[currentBin]);				}			}		}	}}	