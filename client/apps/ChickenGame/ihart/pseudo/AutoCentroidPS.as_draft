package ihart.pseudo{		import ihart.soulwire.ai.Boid;	import flash.geom.Vector3D;	import flash.events.*;		/**	* AutoCentroidPS	* @author Cleo Schneider	* sends a single point which wanders	* around the screen automatically.	* Uses the Boid class	**/	public class AutoCentroidPS extends AbstractPseudoServer{				/**		* Fields		**/		private var blob : Boid;		protected var _config : Object = {											minForce:1.0,											maxForce:2.0,											minSpeed:1.0,											maxSpeed:3.0,											minWanderDistance:10.0,											maxWanderDistance:100.0,											minWanderRadius:5.0,											maxWanderRadius:20.0,											minWanderStep:0.1,											maxWanderStep:0.9,											boundsRadius:250,											numBoids:120											};							/**		* Constructor		**/		public function AutoCentroidPS(){			super();		}		/**		* Override the createBlobs function to create one blob		**/		protected override function createBlobs() : void{			createBlob()			blobHolder.addChild(blob.renderData);		}				/**		* Create a blob : Boid taking advantage of 		* established functionality		**/		protected function createBlob() : void		{			blob = new Boid();						setProperties(blob);			blob.renderData = blob.createDebugShape(); 						blobHolder.addChild(blob.renderData);		}				/**		* Set the properties of a single boid		**/		protected function setProperties(boid : Boid) : void		{			boid.edgeBehavior = Boid.EDGE_BOUNCE;			boid.maxForce = Math.random()*(_config.maxForce-_config.minForce)+_config.minForce;			boid.maxSpeed = Math.random()*(_config.maxSpeed-_config.minSpeed)+_config.minSpeed;			boid.wanderDistance = Math.random()*(_config.maxWanderDistance-_config.minWanderDistance) + _config.minWanderDistance;			boid.wanderRadius = Math.random()*(_config.maxWanderRadius-_config.minWanderRadius) + _config.minWanderRadius;			boid.wanderStep = Math.random()*(_config.maxWanderStep-_config.minWanderStep) + _config.minWanderStep;			boid.boundsRadius = stage.stageWidth * 0.6;			boid.boundsCentre = new Vector3D(stage.stageWidth >> 1, stage.stageHeight >> 1, 0.0);						if(boid.x == 0 && boid.y == 0)			{				boid.x = boid.boundsCentre.x + Math.random()*200 - 100;//random(-100, 100);				boid.y = boid.boundsCentre.y + Math.random()*200 - 100;//random(-100, 100);				boid.z = Math.random()*200 - 100;//random(-100, 100);								var vel : Vector3D = new Vector3D(Math.random()*4 - 2,/*random(-2, 2),*/ Math.random()*4 - 2,/*random(-2, 2),*/ Math.random()*4 - 2/*random(-2, 2)*/);				boid.velocity.incrementBy(vel);			}		}				/**		* Make the blob wander around the scene		**/		protected override function updateBlob() : void{			// Tell the Boid to wander randomly			blob.wander();						// Update and render			blob.update();			blob.render();		}				/**		* override the step function		* Every time it refreshes send the new coordinates of the blob		**/		protected override function step(event : Event = null) : void{			updateBlob();			var currentPosition : String = "1:0," + blob.x + "Y" + blob.y + "WHT0;";			//if the blob is within the scene send the coordinates accross			if(blob.x>=0 && blob.y>=0 && blob.x<=w && blob.y<=h){				//send the current position across the server				send(currentPosition);			}		}	}}