package ihart.event{		import flash.events.*;	import flash.net.XMLSocket;	/**	* CVManager	* @author Felicia Cordeiro 11/23/2010	* @author Cleo Schneider	* CVManager is an event dispatcher which uses a socket's dataHandler to	* alert the user of new input	**/	public class CVManager extends EventDispatcher{				/*		* Fields		*/				//set up the socket 		private var hostName:String;        private var port:uint;        private var socket:XMLSocket;				// the number of regions of interest		private var regionOfInterest : int;						/**		* Constructor that sets up the socket with the given hostName and port,		* connects and sets up listeners		* on data recieved, dispatches a new CVEvent which passes the string		* recieved by the dataHandler		*		* @param hostName The host name to set the socket up with		* @param port The port to set the socket up with		* @param regionOfInterest The number of regions of interest		*		**/		public function CVManager(hostName : String, port : uint, regionOfInterest:int=0){			//assign the hostName and port to the fields for safe keeping			this.hostName = hostName;			this.port = port;			this.regionOfInterest=regionOfInterest;			//create a new socket			socket = new XMLSocket();			configureListeners(socket);			if(hostName && port){				socket.connect(hostName, port);			}		}				/**		* Configure all listeners for the socket		* close - what happens when the socket is closed		* connect - what happens when the socket connects to the server		* data - what to do with the data being sent across the server		* ioError - how to handle an io error		* progress - moniter the progress of a transfer		* security error - how to handle a security error		* For all listeners print out the name of the listener and the event,		* unless otherwise specified		*		* @param dispatcher The event dispatcher to add the listeners to		*		**/		private function configureListeners(dispatcher:IEventDispatcher):void {            dispatcher.addEventListener(DataEvent.DATA, dataHandler);			dispatcher.addEventListener(Event.CLOSE, closeHandler);            dispatcher.addEventListener(Event.CONNECT, connectHandler);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);        }				/**		* Create a new CVEvent to be dispatched every time we receive 		* input from the socket		* upon receiving the data, create a new CVEventData instance to hold all		* information recieved and then create a new CVEvent		* 		* @param event The event data to be handled		**/        private function dataHandler(event:DataEvent):void {						var isResuming : Boolean = false;		//is resume is used to simulate a click event			var blob : Blob;			var shellData : Array=new Array();			var holeData : Array=new Array();			var faceData: Array=new Array();			var eventData : Array;			var currentInd : int = event.data.indexOf(":");			var numBlobs : int = new Number(event.data.substring( 0, currentInd));       //the number of blobs in this string total									//if the resume character is found at the beginning of the string set is resuming to true			if(event.data.indexOf("R") == 0){				isResuming = true;				//after slice the character off				event.data = event.data.substring(1, event.data.length);			}						for(var i : int = 0; i < numBlobs; i++){				//create a blob object based on the data of the event				blob=parseEventDataToBlob(event,currentInd);								//increment the current index				currentInd = event.data.indexOf(";", currentInd)+1;								//if the type for this blob is shell add it to the shellData array				if(blob.getType() == CVEvent.SHELL){					shellData.push(blob);				}								//if the type for this blob is hole add it to the holeData array				else if(blob.getType() == CVEvent.HOLE){					holeData.push(blob);				}				//if the type for this blob is face, add it to the faceData array				else if(blob.getType()==CVEvent.FACE){					faceData.push(blob);				}			}			//create a multidimensional array containing a row for each type			eventData=new Array(shellData,holeData,faceData);						dispatchEvents(shellData.length,holeData.length,faceData.length, numBlobs,eventData,isResuming);		}				/**		* Parses the event data to find the x, y, width, and height of the 		* current event.		*		* @param event The data event that occured		* @param currentInd The current index into the event data		*		* @return  A blob object with the x, y, width, and height that was parsed		*		**/		private function parseEventDataToBlob(event:DataEvent, currentInd:int):Blob{						//the characteristics of the blob			var bWidth: Number, bHeight:Number, xCoor:Number, yCoor : Number;			var type:int;							xCoor = new Number(findKeyWordPosition(",","Y",currentInd, event)); 			yCoor = new Number(findKeyWordPosition("Y","W",currentInd, event));			bWidth = new Number(findKeyWordPosition("W","H",currentInd, event));			bHeight = new Number(findKeyWordPosition("H","T",currentInd, event));			type = new int(findKeyWordPosition("T",";",currentInd, event));				//create and return a blob with the above characteristics			return new Blob(type,xCoor,yCoor,bWidth,bHeight);		}				/**		* Finds the value between the start and end delimiter at the current index		*		* @param startDelimeter The string or character to start looking at		* @param endDelimeter The String of character to end looking at		* @param currentInd The current index into the event data to begin searching for the startDelimeter		* @param event The data event that occured to be searched		* 		* @return The value between the delimiters, as a string		*		**/		private function findKeyWordPosition(startDelimiter :String, endDelimiter:String, currentInd:int, event:DataEvent ):String{			var startDelimiterIndex:int = event.data.indexOf(startDelimiter, currentInd+1)+1;			var endDelimiterIndex:int = event.data.indexOf(endDelimiter, currentInd+1);						var subString:String = event.data.substring(startDelimiterIndex,endDelimiterIndex);						return subString;		}						/**		* Dispatches events depending on the number of each type of blob.		* If there are more than one of a type of event, dispatch it. 		* If there are any blobs, dispatch all blobs event.		*		* @param numShells The number of shells in the event		* @param numHoles The number of holes in the event		* @param numFaces The number of faces in the event		* @param numBlobs The number of blobs in the event		* @param eventData The array of all the event's data to create new CVEventData		* @param isResuming The boolean stating whether the event was a "mock" click event		* 		**/		private function dispatchEvents(numShells:int, numHoles:int, numFaces:int, numBlobs:int, eventData:Array, isResuming:Boolean):void{			//create new event data and a new event			var cvEventData : CVEventData = new CVEventData(eventData);				//if there are no hole blobs there is no need to dispatch a hole blob event			//similarly if there are no holes there is no need to dispatch a hole event			//default behavior is to dispatch the all blob even because both types are present			if(numShells > 0){				dispatchEvent(new CVEvent(CVEvent.SHELL, cvEventData, isResuming));			} 			if(numHoles > 0){				dispatchEvent(new CVEvent(CVEvent.HOLE, cvEventData,isResuming));			} 			if(numFaces>0){				dispatchEvent(new CVEvent(CVEvent.FACE, cvEventData,isResuming));			}			if (numBlobs > 0 ) {				dispatchEvent(new CVEvent(CVEvent.ALL_BLOBS, cvEventData,isResuming));			}		}						/**		* trace the event		**/		private function closeHandler(event:Event):void {            trace("closeHandler: " + event);        }				/**		* trace the event		**/        private function connectHandler(event:Event):void {            trace("connectHandler: " + event);        }				/**		* trace the event		**/        private function ioErrorHandler(event:IOErrorEvent):void {            trace("ioErrorHandler: " + event);        }				/**		* trace the event		**/        private function progressHandler(event:ProgressEvent):void {            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);        }				/**		* trace the event		**/        private function securityErrorHandler(event:SecurityErrorEvent):void {            trace("securityErrorHandler: " + event);        }	}}