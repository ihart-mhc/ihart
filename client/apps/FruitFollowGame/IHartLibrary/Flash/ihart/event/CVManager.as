package ihart.event{		//constants of types in processing	import flash.events.*;	import flash.net.XMLSocket;	/**	* CVDispatcher	* @author Felicia Cordeiro 11/23/2010	* @author Cleo Schneider	* CVDispatcher is an event dispatcher which uses a socket's dataHandler to	* alert the user of new input	**/	public class CVManager extends EventDispatcher{		/**		* Fields		**/		//set up the socket 		private var hostName:String;        private var port:uint;        private var socket:XMLSocket;		private var regionOfInterest : int;						/**		* Constructor		* Set up the socket with the given hostName and port		* connect and set up listeners		* on data recieved dispatch a new CVEvent passing the string		* recieved by the dataHandler		**/		public function CVManager(hostName : String, port : uint, regionOfInterest:int=0){			//assign the hostName and port to the fields for safe keeping			this.hostName = hostName;			this.port = port;			this.regionOfInterest=regionOfInterest;			//create a new socket			socket = new XMLSocket();			configureListeners(socket);			if(hostName && port){				socket.connect(hostName, port);			}		}				/**		* Configure all listeners for the socket		* close - what happens when the socket is closed		* connect - what happens when the socket connects to the server		* data - what to do with the data being sent across the server		* ioError - how to handle an io error		* progress - moniter the progress of a transfer		* security error - how to handle a security error		* For all listeners print out the name of the listener and the event,		* unless otherwised specified		**/		private function configureListeners(dispatcher:IEventDispatcher):void {            dispatcher.addEventListener(DataEvent.DATA, dataHandler);			dispatcher.addEventListener(Event.CLOSE, closeHandler);            dispatcher.addEventListener(Event.CONNECT, connectHandler);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);        }				/**		* Create a new CVEvent to be dispatched every time we receive 		* input from the socket		* upon receiving the data, create a new CVEventData instance to hold all		* information recieved 		* then create a new CVEvent		**/        private function dataHandler(event:DataEvent):void {						var isResuming : Boolean = false;		//is resume is used to simulate a click event			var blob : Blob;			var shellData : Array=new Array();			var holeData : Array=new Array();			var faceData: Array=new Array();			var eventData : Array;			var currentInd : int = event.data.indexOf(":");			var numBlobs : int = new Number(event.data.substring( 0, currentInd));       //the number of blobs in this string total									//if the resume character is found at the beginning of the string set is resuming to true			if(event.data.indexOf("R") == 0){				isResuming = true;				//after slice the character off				event.data = event.data.substring(1, event.data.length);			}						for(var i : int = 0; i < numBlobs; i++){								blob=parseEventDataToBlob(event,currentInd);				currentInd = event.data.indexOf(";", currentInd)+1;								// if it's not in this region of interest, skip it				if ( blob.getROI() != regionOfInterest )					continue;				//if the type for this blob is shell add it to the shellData array				if(blob.getType() == CVEvent.SHELL){					shellData.push(blob);				}								//if the type for this blob is hole add it to the holeData array				else if(blob.getType() == CVEvent.HOLE){					holeData.push(blob);				}				//if the type for this blob is face, add it to the faceData array				else if(blob.getType()==CVEvent.FACE){					faceData.push(blob);				}			}			//create a multidimensional array containing a row for each type			eventData=new Array(shellData,holeData,faceData);						dispatchEvents(shellData.length,holeData.length,faceData.length, numBlobs,eventData,isResuming);		}				/**		* Parses the event data to find the x, y, width, and height of the 		* current event.		*		* @ return - return a blob object with the x, y, width, height and region of interest that was parsed		*		**/		private function parseEventDataToBlob(event:DataEvent, currentInd:int):Blob{						//the characteristics of the blob			var bWidth: Number, bHeight:Number, xCoor:Number, yCoor : Number, roi : int;			var type:int;							xCoor = new Number(findKeyWordPosition(",","Y",currentInd, event)); 			yCoor = new Number(findKeyWordPosition("Y","W",currentInd, event));			bWidth = new Number(findKeyWordPosition("W","H",currentInd, event));			bHeight = new Number(findKeyWordPosition("H","T",currentInd, event));			type = new int(findKeyWordPosition("T","I",currentInd, event));			// added ASJ for region of interest			roi = new int(findKeyWordPosition("I",";",currentInd, event));			//create and return a blob with the above characteristics			return new Blob( CVEvent.getStringType( type ),xCoor,yCoor,bWidth,bHeight,roi);		}				/**		*		*		*		*		*		**/		private function findKeyWordPosition(startDelimiter :String, endDelimiter:String, currentInd:int, event:DataEvent ):String{			var startDelimiterIndex:int = event.data.indexOf(startDelimiter, currentInd+1)+1;			var endDelimiterIndex:int = event.data.indexOf(endDelimiter, currentInd+1);						var subString:String = event.data.substring(startDelimiterIndex,endDelimiterIndex);						return subString;		}						/**		*		*		*		*		*		**/		private function dispatchEvents(numShells:int, numHoles:int, numFaces:int, numBlobs:int, eventData:Array, isResuming:Boolean):void{			//create new event data and a new event			var cvEventData : CVEventData = new CVEventData(eventData);				//if there are no whole blobs there is no need to dispatch a whole blob event			//similarly if there are no holes there is no need to dispatch a hole event			//default behavior is to dispatch the all blob even because both types are present			//trace( "FINAL numHoles: "+ numHoles + ", numHulls: " + numhulls );			if(numShells > 0){				dispatchEvent(new CVEvent(CVEvent.SHELL, cvEventData, isResuming));			} 			if(numHoles > 0){				dispatchEvent(new CVEvent(CVEvent.HOLE, cvEventData,isResuming));			} 			if(numFaces>0){				dispatchEvent(new CVEvent(CVEvent.FACE, cvEventData,isResuming));			}			if (numBlobs > 0 ) {				dispatchEvent(new CVEvent(CVEvent.ALL_BLOBS, cvEventData,isResuming));			}		}						/**		* trace the event		**/		private function closeHandler(event:Event):void {            trace("closeHandler: " + event);        }				/**		* trace the event		**/        private function connectHandler(event:Event):void {            trace("connectHandler: " + event);        }				/**		* trace the event		**/        private function ioErrorHandler(event:IOErrorEvent):void {            trace("ioErrorHandler: " + event);        }				/**		* trace the event		**/        private function progressHandler(event:ProgressEvent):void {            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);        }				/**		* trace the event		**/        private function securityErrorHandler(event:SecurityErrorEvent):void {            trace("securityErrorHandler: " + event);        }	}}