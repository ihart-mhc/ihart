package ihart.event{	import flash.events.*;	import flash.display.Shape;	import flash.display.MovieClip;	import flash.display.SimpleButton;	/**	* CVButton	* @author CleoSchneider	* last updated 07/13/10	*	* CvButton extends the button class and contains all of its functionality, but overrides the event listener	* listen for hole and hull events from the CVManager	**/	public class CVButton extends SimpleButton{		/**		* Fields		**/		//constants		private static const DELAY = 10;		//instances		private var delay : int = DELAY;		private var cv_man : CVManager;		private var dispatcher : EventDispatcher;		private var h_enabled, s_enabled : Boolean;		//set up the socket with localhost, using port 5204		private var hostName:String = "localhost";        private var port:uint = 5204;								/**		* Constructor		* calls super		**/		public function CVButton(){			//make a call to super to inherit all necessary functions			super();			//initialize the enabled events			h_enabled = false;			s_enabled = false;			//the cv manager to worry about dispatched events			cv_man = new CVManager(hostName, port);			//add listeners to the cv manager			cv_man.addEventListener("hole", holesReceived);			cv_man.addEventListener("shell", shellsReceived);			cv_man.addEventListener("all blobs", allBlobsReceived);		}				/**		* enable		* enable shells or holes or both		* this dictates whether click events will work with your buttons		* It is necessary that this method be called if the user wants to use clicks		* return void		**/		public function enable(type : int) : void{			//if the type matches holes than enable holes			if(type == CVEvent.HOLE){				h_enabled = true;			}			//if the type matches shells than enable shells			if(type == CVEvent.SHELL){				s_enabled = true;			}		}				/**		* allBlobsRecieved		* when any blobs are recieved, if we have enabled holes and shells, a blob overlaps, and stays there for long enough		* dispatch a click event		* return void		**/		public function allBlobsReceived(e : CVEvent) : void{			//walk along the holes			for(var i: int = 0; i< e.getNumBlobs(); i++){				//check for overlap with the button				if(checkOverlap(e.getX(i), e.getY(i), e.getWidth(i), e.getHeight(i))){					//if holes are enabled					if(h_enabled && s_enabled){						//if the delay is greater than 0 then decrement						if(delay>0){							delay--;							//break out of the loop so we don't doubly decrement for this event							break;						}else{							//reset the delay							delay = DELAY;							//dispatch a click event							dispatchEvent(new Event(MouseEvent.CLICK));							//stop walking we don't care about two blobs over the button							break;						}					}				}			}		}				/**		* holesRecieved		* when holes are recieved, if we have enabled holes, a hole overlaps, and stays there for long enough		* dispatch a click event		* return void		**/		public function holesReceived(e : CVEvent) : void{ 			//walk along the holes			for(var i: int = 0; i< e.getNumBlobs(); i++){				//check for overlap with the button				if(checkOverlap(e.getX(i), e.getY(i), e.getWidth(i), e.getHeight(i))){					//if holes are enabled					if(h_enabled){						//if the delay is greater than 0 then decrement						if(delay>0){							delay--;							//break out of the loop so we don't doubly decrement for this event							break;						}else{							//reset the delay							delay = DELAY;							//dispatch a click event							dispatchEvent(new Event(MouseEvent.CLICK));							//stop walking we don't care about two blobs over the button							break;						}					}				}			}		}				/**		* shellsRecieved		* when shells are recieved, if we have enabled shells, a shell overlaps, and stays there for long enough		* dispatch a click event		* return void		**/		public function shellsReceived(e : CVEvent) : void{			//walk along the holes			for(var i: int = 0; i< e.getNumBlobs(); i++){				//check for overlap with the button				if(checkOverlap(e.getX(i), e.getY(i), e.getWidth(i), e.getHeight(i))){					//if holes are enabled					if(s_enabled){						//if the delay is greater than 0 then decrement						if(delay>0){							delay--;							//break out of the loop so we don't doubly decrement for this event							break;						}else{							//reset the delay							delay = DELAY;							//dispatch a click event							dispatchEvent(new Event(MouseEvent.CLICK));							//stop walking we don't care about two blobs over the button							break;						}					}				}			}		}				/**		* checkOverlap		* Check overlap		* return: true if 2/3 of the blob is overlapping		* else return false		**/		public function checkOverlap(blobx : int, bloby : int, blobW : int, blobH : int){			//calculate the range of x values and the range of y values for the blob			var lxbound : int = blobx - blobW/2;			var uybound : int = bloby - blobH/2;			//create a new sprite to test overlap			var rect:Shape = new Shape();			rect.graphics.drawRect(lxbound, uybound, blobW, blobH);						//then test to see if any corner of the bounding rect is overlapping with the button's corner			if(this.hitTestObject(rect)){				return true;			}			//there was no overlap			return false;		}	}}