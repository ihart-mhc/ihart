package ihart.demo.CVZoom{	import flash.geom.Vector3D;	import flash.events.*;	import flash.display.MovieClip;	import flash.utils.Timer;	import flash.display.Sprite;	import flash.display.Shape;	import flash.geom.Matrix;	import flash.display.BitmapData;	import ihart.event.*;		[SWF(width="800", height="500", backgroundColor="#FFFFFF", frameRate="31")]	/**	* CVBubbles	* @author CleoSchneider	* Creates bubbles using information collected from a CVEvent	*/	public class CVZoom extends Sprite	{					/**		*Fields		**/		//set up the socket with localhost, using port 5204		private var hostName:String = "localhost";//"138.110.8.61";        private var port:uint = 5204;		private var cvManager : CVManager;				//create a vector of bubbles to add to if the there is a hole in front of the 		private var _bubbles : Vector.<Bubble> = new Vector.<Bubble>();		//a sprite to hold the background and add it to the stage		private var _seaHolder : Sprite;		//a timer for the data handler, so we don't make a million bubbles		private var timer : Timer;		private var faceTimer:Timer;		private var delay : int = 15;		private var repeat : int = 0;				private var zoomWInc:Number, zoomHInc:Number; //5 percent increase				private var previousFaceWidth:int, previousFaceHeight:int, currentFaceWidth:int, currentFaceHeight:int,eventNumber:int=0;		private var previousMovieWidth:int, previousMovieHeight:int, currentMovieWidth:int, currentMovieHeight:int;		/**		* Constructor		**/		public function CVZoom(){						//create a cvManager to dispatch a whole blob event			cvManager = new CVManager(hostName, port);			//we must add an event listener to the cv manager in order to know when			//we have received data			cvManager.addEventListener(CVEvent.FACE, getData);				currentMovieWidth=fractalPic.width;			currentMovieHeight=fractalPic.height;		}				/**		* getData		* For every time a hole is sent over add a bubble to the screen 		* and to the bubble vector.		**/        private function getData(e : CVEvent):void {							var numBlobs : int = e.getNumBlobs();			for(var i : int = 0; i<numBlobs; i++){				currentFaceWidth=e.getWidth(i);				currentFaceHeight=e.getHeight(i);								if(eventNumber>0){									if(currentFaceWidth-previousFaceWidth>15 && currentFaceHeight-previousFaceHeight>15){						zoomWInc=(1- previousFaceWidth/currentFaceWidth)*2;						zoomHInc=(1- previousFaceHeight/currentFaceHeight)*2;						zoomIn(fractalPic);					}					if(previousFaceWidth-currentFaceWidth>15 && previousFaceHeight-currentFaceHeight>15){						zoomWInc=(1- currentFaceWidth/previousFaceWidth)*2;						zoomHInc=(1- currentFaceHeight/previousFaceHeight)*2;						zoomOut(fractalPic);											}				}				previousFaceWidth=currentFaceWidth;				previousFaceHeight=currentFaceHeight;			}			eventNumber++;	   	}			 		function zoomIn(movie:MovieClip) {			trace(movie.scaleY + "Y scale" + movie.scaleX + " X scale");			if(movie.scaleY <5 && movie.scaleX < 5) {							  movie.scaleX += zoomWInc;			  movie.scaleY += zoomHInc;			  /* NOT NEEDED IF EVERYTHING CENTERED! 				previousMovieWidth=currentMovieWidth;				previousMovieHeight=currentMovieHeight;			  			  currentMovieWidth=movie.width;			  currentMovieHeight=movie.height;			  				movie.x-=((currentMovieWidth-previousMovieWidth)/2);				movie.y-=((currentMovieHeight-previousMovieHeight)/2);*/			}  								} 						 		function zoomOut(movie:MovieClip) {						if(movie.scaleY > 1 && movie.scaleX > 1) {							  movie.scaleX-= zoomWInc;			  movie.scaleY-=zoomHInc;			  			  /* NOT NEEDED IF EVERYTHING CENTERED! 			  				previousMovieWidth=currentMovieWidth;				previousMovieHeight=currentMovieHeight;							   currentMovieWidth=movie.width;			  currentMovieHeight=movie.height;			  movie.x+=((previousMovieWidth-currentMovieWidth)/2);			movie.y+=((previousMovieHeight-currentMovieHeight)/2);*/						}			} 	}}