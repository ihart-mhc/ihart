package ihart.demo.bubbles{	import flash.geom.Vector3D;	import flash.events.*;	import flash.display.MovieClip;	import flash.utils.Timer;	import flash.display.Sprite;	import flash.display.Shape;	import flash.geom.Matrix;	import flash.display.BitmapData;	import ihart.event.*;		[SWF(width="800", height="500", backgroundColor="#FFFFFF", frameRate="31")]	/**	* CVBubbles	* @author CleoSchneider	* Creates bubbles using information collected from a CVEvent	*/	public class CVBubbles extends Sprite	{					/**		*Fields		**/		//set up the socket with localhost, using port 5204		private var hostName:String = "localhost";//"138.110.8.61";        private var port:uint = 5204;		private var cvManager : CVManager;				//create a vector of bubbles to add to if the there is a hole in front of the 		private var _bubbles : Vector.<Bubble> = new Vector.<Bubble>();		//a sprite to hold the background and add it to the stage		private var _seaHolder : Sprite;		//a timer for the data handler, so we don't make a million bubbles		private var timer : Timer;		private var delay : int = 15;		private var repeat : int = 0;		/**		* Constructor		**/		public function CVBubbles(){						//add a timer so that we don't have a million and a half bubbles			timer = new Timer(delay, repeat);			timer.start();			timer.addEventListener(TimerEvent.TIMER, timerEvent);			timer.addEventListener(TimerEvent.TIMER_COMPLETE, timerComplete);			_seaHolder = addChild(new Sprite()) as Sprite;			_seaHolder.addChild(createSea());			//create a cvManager to dispatch a whole blob event			cvManager = new CVManager(hostName, port);			//we must add an event listener to the cv manager in order to know when			//we have received data			cvManager.addEventListener(CVEvent.HOLE, getData);		}				/**		* Create a timer to send the bubbles up to the top of the screen		* walk over each bubble in the vector and advance it up the screen		**/		public function timerEvent(e : TimerEvent) : void{			for(var i : int =0; i <_bubbles.length; i++){				//if the current bubble is within 3 pixels of the top of the sea pop it.				if(_bubbles[i].y - _bubbles[i].width/2 < 3){					_bubbles[i].gotoAndPlay(2);					_bubbles.splice(i, 1);				}else				_bubbles[i].y = _bubbles[i].y-1;			}		}				/**		* Once the timer is complete print out a message saying so		**/		public function timerComplete(e: TimerEvent) : void{			trace("timer complete");		}				/**		* Create the sea in much the same way we created the fish		* render a shape from the png in the library		*/		protected function createSea() : Shape{			var g : Shape = new Shape();			var matrix:Matrix = new Matrix();			//rotation may be necessary if the camera is not facing the projection			//matrix.rotate(Math.PI);			var seabm:BitmapData=new Sea(800, 500);			g.graphics.beginBitmapFill( seabm, matrix);			g.graphics.moveTo(0, 0);			g.graphics.lineTo(0, seabm.height);			g.graphics.lineTo(seabm.width, seabm.height);			g.graphics.lineTo(seabm.width, 0);			g.graphics.lineTo(0, 0);			g.graphics.endFill();			return g;		}				/**		* getData		* For every time a hole is sent over add a bubble to the screen 		* and to the bubble vector.		**/        private function getData(e : CVEvent):void {				var numBlobs : int = e.getNumBlobs();			var blobX : Number;			var blobY : Number;			var currentBubble : Bubble;			var desiredWidth, desiredHeight : Number;			var scalarX : Number;			var scalarY : Number;						for(var i : int = 0; i<numBlobs; i++){				//get data for whether the blob is a hole				blobX = e.getX(i);				blobY = e.getY(i);				//if it is, then create a bubble at the x and y with 				//create a new bubble on the screen				currentBubble = new Bubble();				desiredWidth = e.getWidth(i);				desiredHeight = e.getHeight(i);				scalarX = desiredWidth/currentBubble.width;				scalarY = desiredHeight/currentBubble.height;				trace("scalarX: " + scalarX + ", scalarY: " + scalarY);				//set the width and height to the width and height of the blob passed				currentBubble.scaleX = scalarX;				currentBubble.scaleY = scalarY;				currentBubble.x = blobX;				currentBubble.y = blobY;				_seaHolder.addChild(currentBubble);				_bubbles.push(currentBubble);			}	   	}	}}