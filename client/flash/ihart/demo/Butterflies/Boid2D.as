package{		import ihart.soulwire.ai.Boid;		import flash.display.Shape;	import flash.geom.Matrix3D;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.Vector3D;	import flash.display.BitmapData;	import flash.geom.Matrix;		public class Boid2D extends Boid	{		public function Boid2D()		{			super();			//lookAtTarget = false;		}				override public function set z( value : Number ) : void		{			//_position.z = value;		}					override public function createBitmapShape( bitmap: BitmapData, size : Number = 6, scale : Number = 1.0 ) : Shape		{			_drawScale = 1 / scale;						var g : Shape = new Shape();			var s : Number = bitmap.width;			var d : Number = bitmap.height;						var matrix: Matrix = new Matrix();			matrix.rotate(Math.PI);						//use bitMapData to texture the fill - beginBitmapFill			//makes a triangle - have to make a box and fill it with bitmap to make picture			g.graphics.beginBitmapFill(bitmap, matrix);			g.graphics.moveTo(0, 0);			g.graphics.lineTo(-s, 0);			g.graphics.lineTo(-s, -d);			g.graphics.lineTo(0, -d);			g.graphics.lineTo(0, 0);			g.graphics.endFill();						return g;		}						/**		 * Updates the DisplayObject used as the Boid's renderData 		 * by setting the Matrix3D of it's transform property. If 		 * lookAtTarget is set to true, the DisplayObject will also 		 * be rotated in order to face the Boids velocity vector		 */		override public function render() : void		{			if ( !_renderData || !_renderData.stage || !_renderData.visible )			{				return;			}						_matrix.identity();						if(_drawScale != 1.0)			{				_matrix.appendScale(_drawScale, _drawScale, _drawScale);			}						if ( _lookAtTarget )			{//				_matrix.pointAt(_velocity);//, Vector3D.X_AXIS, Vector3D.Y_AXIS);				_matrix.pointAt(_velocity, Vector3D.Z_AXIS, Vector3D.Z_AXIS);			}						_matrix.appendTranslation(_position.x, _position.y, _position.z);						_renderData.transform.matrix3D = _matrix;		}	}}