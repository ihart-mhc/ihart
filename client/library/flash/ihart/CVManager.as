package ihart.event{		//constants of types in processing	import flash.events.*;	import flash.net.XMLSocket;	/**	* CVDispatcher	* @author Felicia Cordeiro 11/23/2010	* @author Cleo Schneider	* CVDispatcher is an event dispatcher which uses a socket's dataHandler to	* alert the user of new input	**/	public class CVManager extends EventDispatcher{		/**		* Fields		**/		//set up the socket 		private var hostName:String;        private var port:uint;        private var socket:XMLSocket;		private var regionOfInterest : int;				private var shellData : Array;//=new Array();		private var holeData : Array;//=new Array();		private var faceData: Array;//=new Array();		private var eventData : Array;						/**		* Constructor		* Set up the socket with the given hostName and port		* connect and set up listeners		* on data recieved dispatch a new CVEvent passing the string		* recieved by the dataHandler		**/		public function CVManager(hostName : String, port : uint, regionOfInterest:int=0){			trace("CVManager constructor.");						//assign the hostName and port to the fields for safe keeping			this.hostName = hostName;			this.port = port;			this.regionOfInterest=regionOfInterest;			//create a new socket			socket = new XMLSocket();			configureListeners(socket);			if(hostName && port){				socket.connect(hostName, port);			}		}				/**		* Configure all listeners for the socket		* close - what happens when the socket is closed		* connect - what happens when the socket connects to the server		* data - what to do with the data being sent across the server		* ioError - how to handle an io error		* progress - moniter the progress of a transfer		* security error - how to handle a security error		* For all listeners print out the name of the listener and the event,		* unless otherwised specified		**/		private function configureListeners(dispatcher:IEventDispatcher):void {			trace("in configureListeners.");            dispatcher.addEventListener(DataEvent.DATA, dataHandler);			dispatcher.addEventListener(Event.CLOSE, closeHandler);            dispatcher.addEventListener(Event.CONNECT, connectHandler);            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);            dispatcher.addEventListener(ProgressEvent.PROGRESS, progressHandler);            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);        }				/**		* Create a new CVEvent to be dispatched every time we receive 		* input from the socket		* upon receiving the data, create a new CVEventData instance to hold all		* information recieved 		* then create a new CVEvent		**/        private function dataHandler(event:DataEvent):void {			trace("***********in dataHandler.************");			var isResuming : Boolean = false;		//is resume is used to simulate a click event			var blob : Blob;			//var shellData : Array=new Array();			//var holeData : Array=new Array();			//var faceData: Array=new Array();			//var eventData : Array;						shellData = new Array();			holeData = new Array();			faceData = new Array();			eventData = new Array(); 			//if the resume character is found at the beginning of the string set is resuming to true			if(event.data.indexOf("R") == 0){				isResuming = true;				//after slice the character off				event.data = event.data.substring(1, event.data.length);			}						var currentInd : int = event.data.indexOf(":");			var numBlobs : int = new Number(event.data.substring( 0, currentInd));       //the number of blobs in this string total						/*for(var i : int = 0; i < numBlobs; i++){								blob=parseEventDataToBlob(event,currentInd);				currentInd = event.data.indexOf(";", currentInd)+1;								// if it's not in this region of interest, skip it				if ( blob.getROI() != regionOfInterest )					continue;				//if the type for this blob is shell add it to the shellData array				if(blob.getType() == CVEvent.SHELL){					shellData.push(blob);				}								//if the type for this blob is hole add it to the holeData array				else if(blob.getType() == CVEvent.HOLE){					holeData.push(blob);				}				//if the type for this blob is face, add it to the faceData array				else if(blob.getType()==CVEvent.FACE){					faceData.push(blob);				}			}*/			var messageString : String = event.data;			var areaStart : int = findSpecificInterestArea(regionOfInterest, messageString);			var areaEnd : int = findNextAreaIndex(areaStart + 2, messageString);			if (areaStart < 0){    			return;    		}    		    		if(areaEnd < areaStart){    			areaEnd = messageString.length;    		}						trace("calling parseArea");						var areaIndex : int = Number(messageString.substr(areaStart, 1));			parseArea(areaStart, areaEnd, messageString, areaIndex);						//create a multidimensional array containing a row for each type			eventData=new Array(shellData,holeData,faceData);						dispatchEvents(shellData.length,holeData.length,faceData.length, numBlobs,eventData,isResuming);		}																																																																					private function parseArea(startIndex : int, end : int, messageString : String, areaIndex : int) : void	{ 		trace("in parseArea. messageString = " + messageString);    	//System.out.println("parsing area. range: " + startIndex + " to " + end);    	//System.out.println("***parsing shells");    	parseItems(startIndex, end, messageString, "Shells:", true, areaIndex);    	//System.out.println("***parsing faces");    	parseItems(startIndex, end, messageString, "Faces:", false, areaIndex);    }    private function parseItems(startIndex : int, end : int, messageString : String, searchFor : String, shell : Boolean, areaIndex : int) :  void 	{		trace("in parseItems.");        var itemstartIndex : int = messageString.indexOf(searchFor, startIndex);		trace("in parseItems. 1");        if (itemstartIndex < 0){			trace("in parseItems. 2");        	return;        }		trace("in parseItems. 3");        //System.out.println("   in parseItems. messageString from itemstartIndex is " + messageString.substring(itemstartIndex));        var index : int = itemstartIndex + searchFor.length;        trace("in parseItems. 4");		if (itemstartIndex > end){        	return;        }         trace("in parseItems. 5");        //System.out.println("   in parseItems. messageString from new index is " + messageString.substring(index));        //System.out.println("   (searching for " + searchFor + ") ");                    var type : String = "";        if (shell){			trace("in parseItems. 6");        	type = "shell";        } else {			trace("in parseItems. 7");        	type = "face";        }                var tmpEnd : int = findEndOfCurrentSection(startIndex, messageString);		trace("in parseItems. 8");        if(tmpEnd < end && tmpEnd > 0){        	end = tmpEnd;        }        trace("in parseItems. 9");        var currentFaceEnd : int = messageString.indexOf(" ", itemstartIndex);          //System.out.println("   startIndexing while loop (parseItems) startIndex " + startIndex + ", end " + end);        trace("in parseItems. 10");		while (index < end){ 			trace("in parseItems. 11");        	var blob : Blob = parseItem(index, currentFaceEnd, messageString, type);          	index = currentFaceEnd + 1;			trace("in parseItems. 12");        	currentFaceEnd = messageString.indexOf(" ", index);        	trace("in parseItems. 13");        	if (blob != null){ 				trace("in parseItems. 14");				trace("found a blob!");        		if(shell){					trace("in parseItems. 15");         			shellData.push(blob);        			//System.out.println("    found a shell!");        			//*totalShells++;        		} else {					trace("in parseItems. 16");         			faceData.push(blob);        			//System.out.println("    found a face!");        			//*totalFaces++;        		}        		//allBlobsList.add(blob);        		//totalBlobs++;        	} else {				trace("in parseItems. 17");				trace("did not find a blob.");			}        }		trace("in parseItems. 18");		trace("returning from parseItems.");    }          private function parseItem(startIndex : int, end : int, messageString: String, type : String) : Blob	{  		trace("in parseItem.");    	var blob : Blob = new Blob(type, -1, -1, -1, -1, -1);    	var found : Array = new Array(4);    	var foundIndex : int = 0;        var currentInt : int = 0;        var index : int = startIndex;        var intEnd : int = messageString.indexOf(';', startIndex) + 1;        if(intEnd < 0){    		//System.out.println("      change intEnd to equal end?");    		//intEnd = end;    	}                //System.out.println("      in parseItem. startIndex = " + startIndex + ", end = " + end + ", type = " + type);        //System.out.println("      index = " + index + ", intEnd = " + intEnd);        while (index < end && index < intEnd && foundIndex < found.length){        	//System.out.println("      messageString = " + messageString);        	//System.out.println("      messageString from " + index + " to " + (intEnd - 1) + " = " + messageString.substring(index, intEnd - 1));        	currentInt = int( Number(messageString.substring(index, intEnd - 1)));        	found[foundIndex++] = currentInt;        	        	index = intEnd;        	intEnd = messageString.indexOf(';', intEnd) + 1;        	        	if(intEnd < 0){        		//System.out.println("      changing intEnd to equal end.");        		intEnd = end;        	}        	//System.out.println("      index = " + index + ", intEnd = " + intEnd);        }                if(foundIndex != 4){        	//System.out.println("      didn't find 4 numbers?");        	return null;        }                blob.setX(found[0]);        blob.setY(found[1]);        blob.setWidth(found[2]);        blob.setHeight(found[3]);        return blob;            }         private function findEndOfCurrentSection(startIndex : int, messageString : String) : int 	{		trace("in findEndOfCurrentSection.");    	return messageString.indexOf("]", startIndex);     }    private function findNextAreaIndex(currentIndex : int, messageString : String) : int 	{		trace("in findNextAreaIndex.");        if(currentIndex < 0){            return -1;        }        var index : int = messageString.indexOf('|', currentIndex);        if (index < 1){            return index;        }         //*if (Character.isDigit(messageString.charAt(index - 1))){            return index - 1;        //*}        //*return -1;    }        private function findSpecificInterestArea(area : int, messageString : String) :  int 	{		trace("in findSpecificInterestArea.");    	var search : String = area + "|";    	//System.out.println("in findSpecificArea. search string is '" + search + "'.");     	//System.out.println("returning " + messageString.indexOf(search));     	return messageString.indexOf(search);    }																																																																				/**		* Parses the event data to find the x, y, width, and height of the 		* current event.		*		* @ return - return a blob object with the x, y, width, height and region of interest that was parsed		*		**/		//private function parseEventDataToBlob(event:DataEvent, currentInd:int):Blob{			//the characteristics of the blob			/*var bWidth: Number, bHeight:Number, xCoor:Number, yCoor : Number, roi : int;			var type:int;							xCoor = new Number(findKeyWordPosition(",","Y",currentInd, event)); 			yCoor = new Number(findKeyWordPosition("Y","W",currentInd, event));			bWidth = new Number(findKeyWordPosition("W","H",currentInd, event));			bHeight = new Number(findKeyWordPosition("H","T",currentInd, event));			//type = new int(findKeyWordPosition("T","I",currentInd, event));			type = new int(findKeyWordPosition("T","I",currentInd, event));			// added ASJ for region of interest			roi = new int(findKeyWordPosition("I",";",currentInd, event));			//create and return a blob with the above characteristics			return new Blob( CVEvent.getStringType( type ),xCoor,yCoor,bWidth,bHeight,roi);*/					//}				/**		*		*		*		*		*		**/		private function findKeyWordPosition(startIndexDelimiter :String, endDelimiter:String, currentInd:int, event:DataEvent ):String{			var startIndexDelimiterIndex:int = event.data.indexOf(startIndexDelimiter, currentInd+1)+1;			var endDelimiterIndex:int = event.data.indexOf(endDelimiter, currentInd+1);						var subString:String = event.data.substring(startIndexDelimiterIndex,endDelimiterIndex);						return subString;		}						/**		*		*		*		*		*		**/		private function dispatchEvents(numShells:int, numHoles:int, numFaces:int, numBlobs:int, eventData:Array, isResuming:Boolean):void{			//create new event data and a new event			var cvEventData : CVEventData = new CVEventData(eventData);				//if there are no whole blobs there is no need to dispatch a whole blob event			//similarly if there are no holes there is no need to dispatch a hole event			//default behavior is to dispatch the all blob even because both types are present			//trace( "FINAL numHoles: "+ numHoles + ", numHulls: " + numhulls );			if(numShells > 0){				dispatchEvent(new CVEvent(CVEvent.SHELL, cvEventData, isResuming));			} 			if(numHoles > 0){				dispatchEvent(new CVEvent(CVEvent.HOLE, cvEventData,isResuming));			} 			if(numFaces>0){				dispatchEvent(new CVEvent(CVEvent.FACE, cvEventData,isResuming));			}			if (numBlobs > 0 ) {				dispatchEvent(new CVEvent(CVEvent.ALL_BLOBS, cvEventData,isResuming));			}		}						/**		* trace the event		**/		private function closeHandler(event:Event):void {            trace("closeHandler: " + event);        }				/**		* trace the event		**/        private function connectHandler(event:Event):void {            trace("connectHandler: " + event);        }				/**		* trace the event		**/        private function ioErrorHandler(event:IOErrorEvent):void {            trace("ioErrorHandler: " + event);        }				/**		* trace the event		**/        private function progressHandler(event:ProgressEvent):void {            trace("progressHandler loaded:" + event.bytesLoaded + " total: " + event.bytesTotal);        }				/**		* trace the event		**/        private function securityErrorHandler(event:SecurityErrorEvent):void {            trace("securityErrorHandler: " + event);        }	}}